name: "Build and push docker"
description: "Build and push docker image"

inputs:
  DOCKERHUB_USERNAME:
    description: "Dockerhub username used to read public images"
    required: true
  DOCKERHUB_TOKEN:
    description: "Dockerhub token used to read public images"
    required: true

  AWS_ACCESS_KEY_ID:
    description: "AWS access key used to write to ECR"
    required: true
  AWS_SECRET_ACCESS_KEY:
    description: "AWS secret access key used to write to ECR"
    required: true
  AWS_REGION:
    description: "AWS region"
    required: true
  AWS_ROLE_TO_ASSUME:
    description: "AWS config to use"
    required: true

  registry:
    description: "Image registry host"
    required: true
  public_registry:
    description: "Extra public registry host"
    required: false
    default: ""
  name:
    description: "Name of the image. Example evaka/image"
    required: true
  path:
    description: "Docker context path"
    default: "."
    required: false
  build-args:
    description: "Docker build-args. See docker/build-push-action build-args"
    required: false
    default: ""
  suffix:
    description: "Tag suffix for images"
    default: null
  target:
    description: "Docker target"
    default: null
  push:
    description: "Push images to registry"
    default: true
  load:
    description: "Load docker image"
    default: false
  dockerfile:
    description: "Dockerfile path"
  ecr_type:
    default: 'ecr'
    description: "ecr or ecr-public"
  docker_cache:
    default: "type=s3,region=eu-west-1,bucket=voltti-ci-docker-cache" # type=gha
  cache_from_images:
    default: ""
    required: false
  tag_latest:
    default: ""
    required: false


outputs:
  image:
    description: "Full image name with registry and tag"
    value: "${{ inputs.registry }}/${{ inputs.name }}:${{ github.event.pull_request.head.sha || github.sha }}"
  image_name:
    description: "Short image name without registry and tag"
    value: ${{ inputs.name }}

runs:
  using: "composite"
  steps:
    - name: Login to Docker Hub
      if: ${{ !github.event.pull_request.head.repo.fork }}
      uses: docker/login-action@v2
      with:
        username: ${{ inputs.DOCKERHUB_USERNAME }}
        password: ${{ inputs.DOCKERHUB_TOKEN }}

    - name: Configure AWS
      if: ${{ !github.event.pull_request.head.repo.fork }}
      shell: bash
      run: |
        mkdir -p ~/.aws
        cat << EOF > ~/.aws/config
        [default]
        region = ${{ inputs.AWS_REGION }}
        role_session_name = CI-GHA-voltti
        role_arn = ${{ inputs.AWS_ROLE_TO_ASSUME }}
        source_profile = default
        EOF

        cat << EOF > ~/.aws/credentials
        [default]
        aws_access_key_id = ${{ inputs.AWS_ACCESS_KEY_ID }}
        aws_secret_access_key = ${{ inputs.AWS_SECRET_ACCESS_KEY }}
        EOF

    - name: Set up buildkitd
      shell: bash
      run: |
        docker run -d \
          --privileged \
          --name remote-buildkit \
          -p 1234:1234 \
          -v "${HOME}/.aws/config:/root/.aws/config:ro" \
          -v "${HOME}/.aws/credentials:/root/.aws/credentials:ro" \
          moby/buildkit:v0.11.5 \
          --addr unix:///run/buildkit/buildkitd.sock \
          --addr tcp://0.0.0.0:1234

    - name: Cache buildx
      id: cache-buildx
      uses: actions/cache@v3
      with:
        path: ~/.docker/cli-plugins/docker-buildx
        key: ${{ runner.os }}-cache-buildx

    - name: Build buildx
      if: steps.cache-buildx.outputs.cache-hit != 'true'
      shell: bash
      run: |
        docker buildx bake "https://github.com/docker/buildx.git"
        mkdir -p ~/.docker/cli-plugins
        mv ./bin/build/buildx ~/.docker/cli-plugins/docker-buildx

    - name: Buildx version
      shell: bash
      run: |
        docker buildx version

    - name: Buildx create
      shell: bash
      id: buildx-create
      run: |
        docker buildx create --driver remote docker-container://remote-buildkit --use

    - name: Login to ECR
      if: ${{ !github.event.pull_request.head.repo.fork }}
      shell: bash
      run: |
        aws ${{ inputs.ecr_type }} get-login-password --region ${{ inputs.AWS_REGION }} | docker login --username AWS --password-stdin ${{ inputs.registry }}

    - name: Login to public ECR
      if: ${{ !github.event.pull_request.head.repo.fork && inputs.public_registry }}
      shell: bash
      run: |
        aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ inputs.public_registry }}

    - name: Set tag
      if: startsWith(github.ref, 'refs/tags/v')
      id: tag
      shell: bash
      run: |
        echo "name=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Docker meta
      id: meta
      env:
        DOCKER_METADATA_PR_HEAD_SHA: "true"
      uses: docker/metadata-action@v4
      with:
        images: |
          "${{ inputs.registry }}/${{ inputs.name }}"
          ${{ inputs.public_registry && format('{0}/{1}', inputs.public_registry, inputs.name) }}
        tags: |
          type=ref,event=branch
          type=sha,format=long,prefix=
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}

    - name: Create cache-from
      id: cache
      shell: bash
      run: |
        cache_to="${{ inputs.name }}/${{ github.event.pull_request.head.sha || github.sha }};${{ inputs.name }}/${{ github.ref_name }}"

        cache_from="${{ inputs.docker_cache }},name=${{ inputs.name }}/${{ github.event.pull_request.head.sha || github.sha }}\n"
        cache_from+="${{ inputs.docker_cache }},name=${{ inputs.name }}/${{ github.ref_name }}\n"
        cache_from+="${{ inputs.docker_cache }},name=${{ inputs.name }}/master\n"

        if test -n '${{ inputs.cache_from_images }}'; then
          while IFS= read -r image ; do
            cache_from+="${{ inputs.docker_cache }},name=${image}/${{ github.event.pull_request.head.sha || github.sha }}\n"
            cache_from+="${{ inputs.docker_cache }},name=${image}/${{ github.ref_name }}\n"
            cache_from+="${{ inputs.docker_cache }},name=${image}/master\n"
          done <<< '${{ inputs.cache_from_images }}'
        fi

        echo "from=\"${cache_from}\"" >> $GITHUB_OUTPUT
        echo "to=${cache_to}" >> $GITHUB_OUTPUT

    - name: Build image
      uses: docker/build-push-action@v4
      with:
        context: ${{ inputs.path }}
        load: ${{ inputs.load }}
        push: ${{ !github.event.pull_request.head.repo.fork && inputs.push  }}
        target: ${{ inputs.target }}
        file: ${{ inputs.dockerfile }}
        build-args: ${{ inputs.build-args }}
        cache-from: ${{ !github.event.pull_request.head.repo.fork && fromJson(steps.cache.outputs.from || '') }}
        cache-to: ${{ !github.event.pull_request.head.repo.fork && format('{0},mode=max,name={1}', inputs.docker_cache, steps.cache.outputs.to) || '' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Cleanup buildx
      if: always()
      shell: bash
      run: |
        docker buildx stop

    - name: Cleanup buildkit
      if: always()
      shell: bash
      run: |
        docker rm -f remote-buildkit

    - name: Cleanup aws
      if: always()
      shell: bash
      run: |
        if test -d ~/.aws; then
          rm -rf ~/.aws
        fi
